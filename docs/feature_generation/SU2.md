---

# 欠損構造特徴 SU2 仕様（SU1を基盤とした二次派生）

## 目的
- SU1で生成した一次信号（欠損フラグ・距離・連続長）を時間方向に集計・平滑化し、**局所的な欠損レジーム**（急増・慢性化・回復）を検知する。
- 予測器の分散を不必要に増やさず、**リークなし**で時系列の状態変化を捉える。

## スコープ
- 入力: 生データではなく **SU1出力**（`m/<col>`, `gap_ffill/<col>`, `run_na/<col>`, `run_obs/<col>`）
- 対象グループ: D/M/E/I/P/S/V の全列
- 出力: ローリング統計・指数平滑・遷移統計・正規化派生
- 依存: SU1が先に生成済みであること（fold境界のリセット規約を継承）

## 運用ルール（SU2）
1) 未来参照禁止。すべて **過去方向のみ** のロール・遅延で構成。\
2) 折境界で**状態をリセット**。学習各foldは独立した初期状態。\
3) クリップは上限60を継承（距離・連続長系）。\
4) データ型は省メモリを優先。flag=uint8, small ints=int16, 小数=float32。\
5) 列名は SU1命名に `su2/` プレフィックスを追加し一意化。

## 生成する特徴（定義）
### 1. ローリング統計（過去のみ）
- 対象信号: `m/<col>`, `run_na/<col>`, `run_obs/<col>`
- 窓 `W ∈ {5, 10, 20, 60}`
- 出力:
  - `su2/roll_mean[W]/m/<col>`: 過去Wでの平均欠損率
  - `su2/roll_std[W]/m/<col>`: 欠損フラグの標準偏差
  - `su2/roll_max[W]/run_na/<col>`: 連続NaN最長
  - `su2/roll_max[W]/run_obs/<col>`: 連続観測最長
  - `su2/roll_zscore[W]/m/<col>`: (現在値 - 過去W平均) / 過去W不偏標準偏差（分母<epsは0）
- 計算規約: **包含しない過去**（t時点の値は統計に含めない）。先頭はNA→0埋め可。

### 2. 指数平滑（EWMA/EWSTD）
- 対象信号: `m/<col>` と `gap_ffill/<col>`
- 平滑係数 `α ∈ {0.1, 0.3, 0.5}`
- 出力:
  - `su2/ewma[α]/m/<col>`
  - `su2/ewstd[α]/m/<col>`（Welford型の逐次更新）
  - `su2/ewma[α]/gap/<col>`
- 初期値: 0 または観測開始点の値。折境界で再初期化。

### 3. 遷移・レジーム統計
- `su2/flip_rate[W]/m/<col>`: 過去Wでの 0↔1 遷移回数 / W（小数）
- `su2/burst_score[W]/<col>`: `max_roll(run_na) / (max_roll(run_na) + max_roll(run_obs) + 1e-6)`
- `su2/recovery_lag/<col>`: 直近で run_na>0 から run_obs>0 に変化した時点からの経過日数（clip≤60）

### 4. 正規化・スケーリング
- `su2/minmax[W]/gap/<col>`: 過去Wに対するmin-max正規化（分母<epsは0）
- `su2/rank[W]/gap/<col>`: 過去W内ランク / W（0-1）

## 実装手順（パイプライン）
1) **入力取得**: SU1完成テーブルと`date_id`を受け取る。\
2) **折境界インデックス生成**: CV foldごとに連続チャンクを作成。\
3) **逐次処理**: 各チャンクで時系列順に一次パス。\
   - ローリング統計: `deque` もしくは滑り窓累積和。現在tの出力は **t−1まで** を元に計算。\
   - EWMA/EWSTD: 再帰更新。\
   - 遷移数: `m[t] != m[t-1]` をカウント。\
   - 回復ラグ: run_na→run_obs の境界検出でカウンタリセット。\
4) **型とクリップ**: clip≤60、型ダウンクラス（uint8,int16,float32）。\
5) **カラム選別**: 全欠損・定数化の列はドロップ。\
6) **メタ出力**: `model_meta.json` に SU2列の由来とパラメータを書き出す。